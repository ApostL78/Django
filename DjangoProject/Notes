cd DjangoProject
django admin все доступные команды
python manage.py runserver
python manage.py startapp <название приложения> создание приложения
superuser: admin redcrow34


№5
----------------------------------------------------------------------------------------------------------------
MVC = MTV (Django)

Model View Controller = Model Template View (Django)


----------------------------------------------------------------------------------------------------------------


№6
----------------------------------------------------------------------------------------------------------------

from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('', include('body.urls'))
]
в проекте у каждого приложения должен быть файл urls.py в котором есть все пути конкретного приложения
и из общего файла urls.py перераспределяется методом include

----------------------------------------------------------------------------------------------------------------


№7
----------------------------------------------------------------------------------------------------------------

модели создаются в файле models.py в классе наследующимся от класса Model

from django.db import models

class Task(models.Model):
    title = models.CharField('Заголовок', max_length=50)
    task = models.TextField("Описание", blank=True)
    ......

атрибуты созданного класса являются полями в таблице базы данных.
Классы типа CharField влияют на тип этих полей в форме и базе

----------------------------------------------------------------------------------------------------------------


№8
----------------------------------------------------------------------------------------------------------------

миграции нужны чтобы отправить sql запрос в бд на создание таблицы (структуру таблиц нужно заложить при первой миграции)
при работе в отладочном режиме на локальном сервере необходимо прописать дополнительные настройки

----------------------------------------------------------------------------------------------------------------


№9
----------------------------------------------------------------------------------------------------------------

python manage.py shell ---> from (app_name).modules import (database_name)
вход в django ORM ----> импорт модели с которой хотим работать

ModelName(attribute='value', attribute2 = 'value')
name1 = _
name2 = ModelName(attribute='value', attribute2 = 'value')   создание поля в таблице
name2
name1.save()  сохранение в бд происходит только после этой команды!!!
name2.save()
name = Model_Name.objects.create(attribute='value', attribute2='value2') сохранение автоматически
exit()

----------------------------------------------------------------------------------------------------------------


№10
----------------------------------------------------------------------------------------------------------------

Если присваивать команды переменным то эти команды выполнятся только после обращения к ним (например для распечатки/обработке в цикле)


python manage.py shell ---> from (app_name).modules import (database_name)
name = Model_Name.objects.all() sql запрос на все обьекты

name = Model_Name.objects.filter(att='value')
sql запрос с фильтром:  {'sql': 'SELECT "body_task"."id", "body_task"."title", "body_task"."task", "body_task"."created_at", "body_task"."updated_at", "body_task"."photo", "body_task"."is_published", "body_task"."category_id", "body_task"."views" FROM "body_task" WHERE "body_task"."title" = \'задача 3\' ORDER BY "body_task"."created_at" DESC LIMIT 21', 'time': '0.000'}
name = Model_Name.objects.get(att=value) (вернет 1 обьект или ошибку если в него поступить 0 или более 1 обьекта)

name = Model_Name.objects.order_by('value') ('-value' обратный порядок) вернет все поля в отсортированом виде

task = Task.objects.get(pk=2)
task.title = 'Новый заголовок'
task.save() обновление данных

task = Task.objects.get(pk=2)
task.delete() удаление записи
django.fun ---> уровень модели -----> QuerySets: Making queries описаны все методы чтобы достать/записать/... данные

----------------------------------------------------------------------------------------------------------------


№11
----------------------------------------------------------------------------------------------------------------

в каждом приложении создается папка templates ---> в ней создается папка с названием приложения --> сюда уже идут шаблоны
blog ---> templates ---> blog ---> index.html ....
https://django.fun/docs/django/ru/4.0/ref/templates/builtins/ все теги тут

----------------------------------------------------------------------------------------------------------------


№12
----------------------------------------------------------------------------------------------------------------

для добавления приложения в админку нужно: в папке приложения в файле admin.py прописать admin.site.register(Task)
затем запустить сервер и после прописать admin.site.register(Task, TaskAdmin) для регестрирования класса редактора
TaskAdmin наследуется от admin.ModelAdmin, класс редактор для отображения доп параметров в админке

для настройки приложения в админке в models.py добавить мета класс и в apps.py добавить некоторые параметры
    class Meta:
        verbose_name = 'Задача'
        verbose_name_plural = 'Задачи'
        ordering = ['-created_at']

----------------------------------------------------------------------------------------------------------------


№13
----------------------------------------------------------------------------------------------------------------

для создания связи между таблицами необходимо поле ForeignKey во вторичной модели со свойствами:
1: модель к которой присоеденяют 2: какая операция будет выполнена при удалении первичного ключа
модель к полям которой привязано множество полей другой модели - первичная модель --> другая модель - вторичная

----------------------------------------------------------------------------------------------------------------


№15-16
----------------------------------------------------------------------------------------------------------------

переменные в шаблонах оборачиваются в: {{ name }}
теги: {%  name  %}...{%  endname  %}
фильтры применяются через знак "|" в тегах или для переменных  {%  name|filter_name  %}

----------------------------------------------------------------------------------------------------------------


№18
----------------------------------------------------------------------------------------------------------------

для создания ссылки на страницу в файле urls.py для функции path используем именованный аргумент name=
path('category/<int:pk>/', views.ViewTask.as_view(), name='category')
теперь для указания пути в шаблоне достаточно применить тег {% url 'name' %} и Django вызовет функцию path с этим именем

----------------------------------------------------------------------------------------------------------------


№19
----------------------------------------------------------------------------------------------------------------

наследование шаблонов: создается папка в проекте (не в приложении) с именем templates и в нем создается файл base.html
в приложениях по желанию можно создать отдельные файлы base_appname.html для более удобного использования
и в остальных html файлах наследоватся от этих шаблонов !!! в settings.py в переменной TEMPLATES должно быть следующее:
'DIRS': [os.path.join(BASE_DIR, 'templates')], чтобы Django искал base.html не только в папках приложений

в base.html создаются блоки {% block block_name %}{% endblock %} которые переопределяются в дочерних шаблонах
или расширяются командой {{ block.super }} (команда находится в блоке, который хотим расширять) {% block%}{{block.super}} .....{% endblock %}

с помошью тега {% include 'template_name' %} можно подключать содержимое шаблона в другой шаблон

----------------------------------------------------------------------------------------------------------------


№20
----------------------------------------------------------------------------------------------------------------

в папке приложения создается папка templatetags --> в ней создается пустой файл __init__.py и name_tags.py
в котором прописываются теги. Чтобы использовать эти теги используем {% load name_tags %} и {% func_name as name %}
пример в шаблоне task_list.html

----------------------------------------------------------------------------------------------------------------


№21
----------------------------------------------------------------------------------------------------------------

чтобы перейти на отдельную страницу новость/задачи/заказа нужно в models.py в модели задачи определить метод
get_absolute_url:
    def get_absolute_url(self):
        return reverse_lazy('path_name', kwargs={ 'pk': self.pk })

в шаблоне вместо тега url используем {{ item.get_absolute_url }} и он вернет ссылку на путь path_name который прописан в
 urls.py. В этом пути path() с именем path_name будет вызван указаный метод/класс и в него переданы параметры в kwargs


----------------------------------------------------------------------------------------------------------------


№22
----------------------------------------------------------------------------------------------------------------

статика

----------------------------------------------------------------------------------------------------------------


№23-25
----------------------------------------------------------------------------------------------------------------

для создания формы на странице необходимо создать файл forms.py в нем импортировать формы и модели:
from django import forms
from .models import Task

создать класс для форм наследуемый от forms.ModelForm для связи формы с моделью. В нем нужно обьявить мета-класс:
class TaskForm(forms.ModelForm):
	    class Meta:
	        model = Task модель с которой связываем
	        fields = ['title', 'task', 'is_published', 'category'] все нужные поля для формы
	        widgets = необходимые виджеты

----------------------------------------------------------------------------------------------------------------


№26
----------------------------------------------------------------------------------------------------------------

кастомные валидаторы (вызываются автоматически после валидации если названо правильно):
в том же классе NameForm создаем метод с названием clean_fieldname далее, тк данные прошли начальную валидацию
был сформирован словарь cleaned_data, обращаемся к нему через поле которое хотим валидировать и валидируем.

----------------------------------------------------------------------------------------------------------------


№27
----------------------------------------------------------------------------------------------------------------

для работы со списком объектов из бд (новости/заддачи/...) в файле views.py объевляем класс который наследуется от
ListView, переопределяем атрибут model и передаем нашу модель. Следуя конвенции django создаем файл в папке приложения
modelname_list.html при рендере в него будет передана переменная object_list со всем контекстом

если нужно добавить какой-то контекст - переопределяем метод get_context_data:

    def get_context_data(self, *, object_list=None, **kwargs):
        context = super(HomeTask, self).get_context_data(**kwargs)
        context['title'] = 'Главная страница'
        return context

если нужны не все объекты из модели то переопределяем метод get_queryset:

    def get_queryset(self):
        return Task.objects.filter(is_published=True).select_related('category')

----------------------------------------------------------------------------------------------------------------


№28
----------------------------------------------------------------------------------------------------------------

как отобразить страницу с определенной новостью 'category/<int:pk>/' и передать параметр pk в него показано в видео

----------------------------------------------------------------------------------------------------------------


№29
----------------------------------------------------------------------------------------------------------------

класс, который наследуется от DetailView получает атрибут (например pk) из url и по нему делает запрос Task.objects.get
(pk=self.kwargs['pk'])
Task - указанная модель в нашем классе
для того чтобы передавался pk или slug в модели в методе get_absolute_url указать kwargs={'pk': self.pk}
по конвенции: context_object_name по дефолту object, а template_name = modelname_detail.html

----------------------------------------------------------------------------------------------------------------


№30
----------------------------------------------------------------------------------------------------------------

для создания формы на основе класса связываем созданный класс в views.py с классом в forms.py:
form_class = TaskForm, где TaskForm класс в forms.py
этот новый класс сам сделает все необходимое и в конце чтобы сделать редирект он будет использовать метод
get_absolute_url того класса к кторому привязана форма (например Task)

----------------------------------------------------------------------------------------------------------------


№32-39
----------------------------------------------------------------------------------------------------------------

in ORM lessons

----------------------------------------------------------------------------------------------------------------
name.count()

name = Model_Name.objects.values('field_name', 'field_name'....) все объекты модели но с заданными полями (без
неиспользуемых полей)

name = Model_Name.objects.all() or .filter(att=value) or get(att=value) (only 1 obj)
name = Model_Name.objects.all()[int:int]  срез (без отрицательных значений)

name.connectedModel_set.all() обратный способ достать объект(из первичной модели достать объект вторичной,
пример: достать все новости из данной категории)

name = Model_name.objects.filter(field_name__filter=value)  !!!сравнение значения поля см константой!!!

name = Model_name.objects.filter(<имя поля внешнего ключа>__<имя поля первичной модели>=value)
(пример: category__title='категория 3')
(связующее поле(category тк foreignKey) во вторичной модели(Task)__имя поля первичной модели(Categories) по которому
ищем)
name = firstly_Model.objects.filter(Secondly_model__field__filter='value') (обратна команда предыдушей)
name = Categories.objects.filter(task__title__conteins='задача') (.distinct() если нужны только уникальные)

----

from django.db.models import *
name = Model_name.objects.aggregate(aggregate_filter('field_name'))
(если нужно назвать поле - название=(aggregate_filter(....))

работа с группами:
from django.db.models import *
name = firstly_Model_name.objects.annotate(aggregate_filter('model or model__fieldName')
( task1 = Categories.objects.annotate(cnt=Count('task')) )
( task1 = Categories.objects.annotate(cnt=Count('task')).filter(cnt__gt=0) без категорий в которых нет задач)
( task2 = Categories.objects.annotate(max=Max('task__views')) )
( task3 = Task.objects.annotate(len=Lenght('title')) ) не уверен что Lenght есть
for item in task1:
	print(item.title, item.cnt)

----

from django.db.models import Q
| == или;        & == и;        ~ == не
name = Model_name.objects.filter(Q(field_name__filter=value) | Q(field_name__filter=value))

-----

from django.db.models import F   !!!сравнение значения поля с другим полем этой записи!!!
name = Model_name.objects.get(pk=1)              | правильное изменение значений
name.field_name = F('field_name') + 1            | через ОРМ

name = Model_name.objects.filter(field_name__filter=F('another_field_name'))

-----

можно загрузить сервер вычислениями вместо питона см Proger cource -- Django.... -- 38 -- 17:50

exit()
{% cycle 'red' 'green' %}
inclusion tags работают если не использовалось
наследование от другого шаблона или этот тег
находится в блоке наследуемого шаблона